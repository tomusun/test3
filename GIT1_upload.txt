〇Gitのインストール



ネットでGit for wondowsで検索し、インストール。(設定はデフォルトのままでよい)
インストールされたかどうかはGit Bashというターミナルを立ち上げてみる。
「git version」とコマンドを打って表示されれば問題はない。

〇Gitの操作は



GUIで操作する方法とGit Bashから操作する方法がある。
Git Bashから操作した方がGitの機能を生かせる。

〇Gitで使用するエディタ



Atom
AtomはGitHubの創業者が自由にカスタマイズできる新世代のエディタを開発するという思い
から始まったもの。

〇インストールしたGitの初期設定



■まずユーザー情報を登録する
git config --global user.name "github User name"(ユーザー名を登録) 
■メールアドレスを登録
git config --global user.email GIThubで登録したアドレス
■エディタの登録 ※Atomを登録
git config --global core.editor "atom --wait"
⇒
設定がちゃんとできたかを確認
ユーザーの確認
$ git config user.name
⇒
アドレスの確認
$ git config user.email
⇒
エディタの確認
$ git config core.editor
結果：
atom --wait

※ここまでがGITの初期設定。
いっぺんに確認したい場合は、git config --list
⇒Gitの登録情報すべてが表示される。

〇今回設定した情報はどこに保存されているかというと



homeディレクトリ配下のgitconfigファイル
コマンド
$ cat ~/.gitconfig
結果：

〇ターミナルの頻出コマンドについてまとめます。
Gitはターミナルで作業するので、その時に絶対に覚えておいてほしいコマンドだけまとめます。
cdコマンド



ディレクトリを移動します。

〇lsコマンド



ディレクトリの内容を表示します。 ls -a コマンドで、隠しファイルを含めたディレクトリ全内容を表示します。

〇mkdirコマンド



ディレクトリを新規作成します。

〇rmコマンド



ファイルを削除します。

〇pwdコマンド



現在のパスを表示

〇cpコマンド



ファイルをコピーします。

〇mvコマンド



ファイルの移動とファイル名の変更を行います。

〇catコマンド



ファイルの中身を表示します。

〇どういう風にGitがデータを保存しているかというと



Gitは
差分ではなくスナップショットとして丸ごと保存
■まるまる保存している
バージョン1
ファイルＡ
ファイルＢ
ファイルＣ
⇒
バージョン2
ファイルＡ 　※そのまま
ファイルＢ1　※変更
ファイルＣ1　※変更
差分ではなくスナップショットとして丸ごと保存
⇒
バージョン3
ファイルＡ1　※変更
ファイルＢ1　※そのまま
ファイルＣ2　※変更
⇒
スナップショットで保存することで複数人で開発するときのスピードを上げることが
できる。
複数人に人が並行して開発できるようブランチを切って開発のバージョンを枝分かれして開発
差分だといちいち計算してくてはならなくてスナップショットとして保存すれば差分を計算
しなくていい分、とても早くブランチを切ったり、マージをすることができる。
※ちなみにＧＩＴ以前のバージョン管理の多くは差分としてデータを保存していてブランチを切るのに大変時間がかかっていた。大規模なプロジェクトだと数十秒かかったりする。
ＧＩＴだとそこが一瞬でできる。こういった事情があってLinuxの作者はGITを自作した。

〇バージョンを記録して何ができるようになるのか



バージョンを記録することで以前の状態に戻すことができる。
コミットでバージョンを記録している。

〇ローカルの作業の流れ



ローカルは3つのエリアに分かれている
ワークツリー⇒ステージ⇒レポジトリ
⇒
■ワークツリー
ファイルを変更したりする手元の作業場所
■ステージ
コミットする変更を準備する場所(ファイル変更をgit addで追加)
※コミットはスナップショットを記録すること
■リポジトリ
スナップショットを記録(コミット git commit)

〇なぜステージがあるのか



■手元でファイルをたくさん変更したときに変更が完了したファイルもあれば変更してないファイル
もある。変更完了したやつだけコミットしたい時がある。
そういうときのために変更が完了したやつだけを記録できるよう変更するファイルをステージに記録してステージに追加された変更分だけリポジトリに記録するという仕組み。

〇Gitのデータ構造
裏側で何が起こっているか



ワークツリー index.html
git add
index.htmlのファイルの中身を圧縮した圧縮ファイルを圧縮ファイルAをリポジトリに保存する。
圧縮ファイルAができたらインデックスというファイルにindex.htmlのファイルの中身は
圧縮ファイルAだというファイル名とファイルの中身をマッピングした情報を保存していく。
これがステージに追加するときに裏側で起こっていること。
⇒
コミットするとインデックスのファイル構成を基にツリー1というファイルが作られる。
ツリー1はインデックスに追加するファイルAのファイル構成を改めて保存したもの。
ツリー1というファイルを作ったらコミット1というファイルを作っていく。
コミット1はいくつか情報が記載されいている
 ツリー1
 作成者(コミットした人の名前とその人のメールアドレス(初期設定でやったやつ。))
 日付(コミットした日付）
 コミットメッセージ(何のためにコミットするのか)
⇒ツリー1からファイル構成(ファイル名とファイル内容)が分かるのでコミットしたときのスナップショットが分かるようになる。だれがいつ何のためにが分かる。
ツリー1とコミット1を作るのが「git commit」
※リポジトリには圧縮ファイルA、ツリー1、コミット1という3つのファイルが保存されている。
3種類のファイルを作成してデータを保存している。

〇変更分をコミットしたときは裏側でどのようなことが行われているのか
ワークツリーでcss/home.cssを新規作成したとする。



ステージに追加するときは圧縮ファイルを作成する。home.cssを圧縮した圧縮ファイルB
次にインデックスに圧縮ファイルBはcss/home.cssだよというファイル構成を追記する。
これでステージに追加できたのでコミットしていく。
コミットする際はツリー2というツリーファイルを新規作成する。ツリー2には今のインデックスの状態、ファイル構成が記録される。ツリー2が保存できたらコミット2というファイルを作成
コミット2
 ツリー2
 親コミット1(コミット1を親コミットとして記録。直前のコミットを自分の親コミットして保存する。これは変更履歴をたどれるようにしている)
 作成者
 日付
 コミットメッセージ

〇ちなみにインデックスとツリー2がなぜ別ファイルなのか



ツリー2
index.html   圧縮ファイルA
css/home.css 圧縮ファイルB
インデックス
index.html   圧縮ファイルA
css/home.css 圧縮ファイルB
⇒
ほぼ一緒な内容なのでファイルなので一緒でもいいのではないか。
これはたくさんのファイルを変更していたときに一部のファイルを先にコミットしたいという時があったりする。
そういうときのためにまずコミットしたいファイルをステージに追加するようになっている。
ステージに追加するたびにツリーファイルを作成したらいいのではないかと思うかもしれないがそれでは非常に非効率。
ステージに追加してなんどもコミットせずステージに追加されたとする。
もし、そのためにツリーファイルに作成したりすると使わない無駄ファイルが量産
されてしまう。なのでステージに追加したときはインデックスという1つのファイルに
上書きしておいてコミットするときにだけツリーというファイルに保存するようになっている

〇上記のindex.htmlに変更を加えた場合



■index.htmlを圧縮した圧縮ファイルCを作る。この時圧縮ファイルが作られるのは
index.htmlでhome.cssについては作られない。
ファイルの中身が違うときにだけ作られるようになっている。
圧縮ファイルを作成したらその情報をインデックスに追記していく。
インデックスの中身はindex.htmlの中身は圧縮ファイルAだよと書かれてい
たところを圧縮ファイルCだよと書き換えられる。ここまででステージに追加する
ことができた。
コミットするとまずツリーを作成していき、インデクスの内容を元にツリー3という
新しいツリーファイルを作成する。
ツリーファイルを作成したらコミット3というコミットファイルを新しく作成する
 ツリー3
 親コミット2
 作成者
 日付
 コミットメッセージ
※コミット2と3のスナップショットを比較すれば前の変更からの差分も分かる。
ここまででコミット完了

〇GITのデータ構造のまとめ



■GITはリポジトリに圧縮ファイル、ツリー、コミットファイルを作成することでデータを保存している。
ステージに追加するときに圧縮ファイルが作られ、コミットするときにツリーとコミットが作られる。
その中のコミットが親コミットを持つことで変更履歴をたどることが出来る。
こういったことから分かることはGITの本質としてデータを圧縮してスナップショットで
保存していること。
Gitのコマンドはそのデータに対して色々な操作をしている。
※Gitは変更履歴を保存する時、圧縮ファイル、ツリーファイル、コミットファイルという形でスナップショットを記録しています。
Gitの実体は基本的にはこれだけです。とてもシンプルですね。
Gitのコマンドは、この3つのGitオブジェクトに対して何らかの操作をしているだけです。
これから色々なコマンドを学んでいきます。その時、コマンドを闇雲に覚えるのではなく、このデータ構造に対してどういう操作をしているコマンドなのかということをイメージしてもらえれば、Gitが実際どのようなことをしているかがわかると思います

・treeコマンドのインストール方法
Windowsの場合



1. ホームディレクトリ直下に .bashrc  ファイルを作成します (~/.bashrc )
2. そのファイルに以下を記載します。
    alias tree='cmd //c tree //A //F'
3. Git Bashを再起動します。
※ 初回起動時にエラー文が表示されますが、問題ないため無視して大丈夫です。
これでtreeコマンドを使用できるようになります。

〇自分のPCにGITのリポジトリを作成



自分のフォルダに移動したらgit init
※initializeの略
コマンドを打つと.gitディレクトリが作成される。(ローカルリポジトリのこと)
.gitディレクトリの中にはGITで必要なほとんどすべてのものが含まれている。
(圧縮ファイル、ツリーファイル、コミットファイル、ステージとして使用したインデックス
ファイル、設定ファイル)

〇GITリポジトリ(ローカルリポジトリ)の作成手順




cd C:/~/udemy_code
mkdir git_tutorial
cd git_tutorial
$ git init
結果：Initialized empty Git repository in C:/~/udemy_code/git_tutorial/.git/
⇒空のGITリポジトリが作られたよと表示

〇実際に作られているか確認



$ ls -a
結果：./  ../  .git/
※lsはディレクトリの中身を表示するコマンド
-aはallの略
.gitのドットは隠れフォルダのこと。

〇.gitの中身を見てみる



$ ls .git/
結果：config  description  HEAD  hooks/  info/  objects/  refs/
⇒
objectsというディレクトリはリポジトリの本体。
この中に圧縮ファイルやツリーファイル、コミットファイルが保存されていく。
configというファイルはGITの設定ファイル
※git addをするとここのなかにインデックスファイルも追加される
